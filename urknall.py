import typer
import subprocess
import logging
import yaml
import sys


class Urknall:
    """ a polyglot package installer working with PURL """
    def __init__(self, urknall_file_path: str):
        logging.getLogger().setLevel(logging.INFO)
        self.yaml_path = urknall_file_path
        self.commands = self.parse()

    def parse_install_cmds_to_dict(self, inst_cmds: list):
        cmd_dict = {}
        for inst_cmd_dict in inst_cmds:
            inst_cmd_key = next(iter(inst_cmd_dict))
            inst_cmd = inst_cmd_dict[inst_cmd_key]
            cmd_dict[inst_cmd_key] = inst_cmd
            # logging.info(f"install command {inst_cmd_key} :::: {inst_cmd}")
        return cmd_dict

    def parse(self) -> list:
        with open(self.yaml_path, "r") as f:
            config = yaml.load(f.read(), Loader=yaml.Loader)

        commands = []

        if config["new_environment"]:
            name = config["name"]
            commands.append(f"call conda env remove -n {name}")
            commands.append(f"call conda create -y -n {name}")
            commands.append(f"call conda activate {name}")

        cmd_dict = self.parse_install_cmds_to_dict(config["install_cmds"])

        for package_purl in config["packages"]:
            # logging.info(f"installing package: {package_purl}")
            scheme, remainder = package_purl.split(":", 1)
            if scheme == "cmd":
                commands.append("call " + remainder)
                continue
            elif scheme != "pkg":
                raise Exception("NO CMD OR PKG SCHEME")
            pkg_type, remainder = remainder.split("/", 1)
            package = remainder
            if "@" in remainder:
                package = remainder.split("@")[0]
                remainder = remainder.split("@")[1]
            else:
                remainder = ""
            version = ""
            urlencoded_params = ""
            if remainder:  # remainder in form of X.Y.Z?urlencoded=parameters
                version = remainder.split("?")[0]
                if "?" in remainder:
                    urlencoded_params = remainder.split("?")[1]

            # logging.info(f"scheme: {scheme}")
            # logging.info(f"pkg_type: {pkg_type}")
            # logging.info(f"package: {package}")
            # logging.info(f"version: {version}")
            # logging.info(f"remainder: {urlencoded_params}")

            install_cmd = cmd_dict[pkg_type]
            # logging.info(install_cmd)
            command = f"{install_cmd} {package}"
            if version:
                command += "=" + version
            command = "call " + command
            commands.append(command)
            logging.info(f"purl: {package_purl}")
            logging.info(f"command: {command}")

        return commands

    def install(self):
        file_name = "urknall.bat"
        with open(file_name, "w") as f:
            content = "rem this file is generated by urknall.py from urknall.yaml\n"
            content += "@echo on\n"  # TODO off
            if self.commands:
                content += "\n".join(self.commands)
            f.write(content)
        command = f"{file_name}"
        logging.info(f"running command: {command}")
        proc = subprocess.run(
            command,
            stdout=sys.stdout,
            shell=True,
        )
        return_code = proc.returncode
        logging.info(f"return_code: {return_code}")
        if return_code != 0:
            raise Exception("ERROR @ install. Check urknall.bat")
        # subprocess.check_output(command, shell=True)


def main(urknall_file_path: str):
    logging.info(f"reading {urknall_file_path}")
    u = Urknall(urknall_file_path)
    u.install()


if __name__ == "__main__":
    typer.run(main)

"""
    def create_environment(self, name: str):
        if self.new_environment:
            self.create_environment(self.name)

        for command in self.commands:
            self.run_command(command)
            subprocess.check_output(command, shell=True)
        commands = [f"conda create --name {name}",
                    f"conda activate {name}"]
        for command in commands:
            subprocess.check_output(command, shell=True)

"""
