# generated by datamodel-codegen:
#   filename:  swagger.yaml
#   timestamp: 2021-01-15T11:04:18+00:00

from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Dict, Any

import yaml
from pydantic import BaseModel, Extra


class Plugin(BaseModel):
    name: Optional[str] = None
    dll_path: Optional[str] = None
    preset_path: Optional[str] = None

    def __init__(self, name: str, dll_path: str, preset_path: str, **data: Any):
        super().__init__(**data)
        self.name = name
        self.dll_path = dll_path
        self.preset_path = preset_path


class DawConfig(BaseModel):
    config_name: Optional[str] = None
    daw_config_path: Optional[str] = None
    mrs_watson_64bit_path: Optional[str] = None
    mrs_watson_32bit_path: Optional[str] = None
    nano_host_64bit_path: Optional[str] = None
    nano_host_32bit_path: Optional[str] = None
    pattern_path: Optional[str] = None
    plugin_path: Optional[str] = None
    preset_path: Optional[str] = None
    projects_path: Optional[str] = None
    rendered_path: Optional[str] = None

    def __init__(self, config_name, plugin_path, preset_path, daw_config_path, pattern_path, projects_path,
                 mrs_watson_32bit_path, mrs_watson_64bit_path, nano_host_64bit_path, nano_host_32bit_path,
                 rendered_path, **data: Any):
        super().__init__(**data)
        self.nano_host_32bit_path = nano_host_32bit_path
        self.nano_host_64bit_path = nano_host_64bit_path
        self.mrs_watson_64bit_path = mrs_watson_64bit_path
        self.mrs_watson_32bit_path = mrs_watson_32bit_path
        self.rendered_path = rendered_path
        self.projects_path = projects_path
        self.pattern_path = pattern_path
        self.daw_config_path = daw_config_path
        self.preset_path = preset_path
        self.plugin_path = plugin_path
        self.config_name = config_name

    def get_dict(self):
        return self.__dict__.items()

    @classmethod
    def hardcoded_default(cls) -> DawConfig:
        config_name = "default"
        daw_config_path = "data\\daw_config"
        mrs_watson_64bit_path = "tools\\MrsWatson-0.9.8\\Windows\\mrswatson64.exe"
        mrs_watson_32bit_path = "tools\\MrsWatson-0.9.8\\Windows\\mrswatson.exe"
        nano_host_64bit_path = "tools\\Tone2 NanoHost v1.0.2\\NanoHost64bit.exe"
        nano_host_32bit_path = "tools\\Tone2 NanoHost v1.0.2\\NanoHost32bit.exe"
        pattern_path = "data\\patterns"
        plugin_path = "plugins"
        preset_path = "plugins\\presets"
        projects_path = "data\\projects"
        rendered_path = "data\\rendered"
        return DawConfig(config_name, plugin_path, preset_path, daw_config_path, pattern_path, projects_path,
                         mrs_watson_32bit_path, mrs_watson_64bit_path, nano_host_64bit_path, nano_host_32bit_path,
                         rendered_path)


class Pattern(BaseModel):
    name: Optional[str] = None
    plugin: Optional[Plugin] = None
    midi_path: Optional[str] = None


class Playlist(BaseModel):
    name: str
    bpm: int
    patterns: Optional[List[Pattern]] = None
    playlist_dict: Optional[Dict[str, Pattern]] = None

    def __init__(self, **kwargs):
        super(Playlist, self).__init__(name=kwargs["name"], bpm=kwargs["bpm"])
        self.patterns = []
        self.playlist_dict = {}


class Daw(BaseModel):
    daw_config_folder: Optional[str] = None
    daw_config: Optional[DawConfig] = None
    playlist: Optional[Playlist] = None
    registered_plugins: Optional[List[Plugin]] = None

    def __init__(self, **kwargs):
        super().__init__()
        self.daw_config_folder = "data\\daw_config"
        self.daw_config = DawConfig.hardcoded_default()
        self.playlist = Playlist(name="default", bpm=90)
        self.registered_plugins = []

    def load_daw_config(self, config_name: str = "default"):
        print(f"loading daw_config {config_name}")
        try:
            path_str = f"{self.daw_config_folder}\\{config_name}.yaml"
            path = Path(path_str).resolve()
            with open(path, "r") as f:
                return yaml.load(f.read(), Loader=yaml.Loader)
        except Exception as e:
            print(f"Error!: {e}")
            return None

    def register_plugin(self, p: Plugin) -> None:
        self.registered_plugins.append(p)

    def get_plugin_by_name(self, name: str) -> Plugin:
        for p in self.registered_plugins:
            if p.name == name:
                return p

    def get_pattern_by_name(self, name: str) -> Playlist:
        for p in self.playlist.patterns:
            if p.name == name:
                return p
